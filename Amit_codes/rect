private Point_2D[] twoMorePoints() {
		Point_2D _lower_Right_Edge = new Point_2D(_upper_Right_Edge.x(), _lower_Left_Edge.y());
		Point_2D _upper_left_Edge = new Point_2D(_lower_Left_Edge.x(), _upper_Right_Edge.y());

		return new Point_2D[]{_lower_Left_Edge, _upper_left_Edge, _lower_Right_Edge, _upper_Right_Edge};
	}
public void rotate(Point_2D center, double angleDegrees) {
    Point_2D[] points = twoMorePoints();
    for (int i = 0; i < points.length; i++) {
        points[i].rotate(center, angleDegrees);
    }
}


	private Point_2D calculateRectangleCenter(Point_2D upperLeft, Point_2D lowerRight) {
		double centerX = (upperLeft.x() + lowerRight.x()) / 2.0;
		double centerY = (upperLeft.y() + lowerRight.y()) / 2.0;
		return new Point_2D(centerX, centerY);
	}

public void rotate(Point_2D center, double angleDegrees) {
		Point_2D rectangleCenter = calculateRectangleCenter(_lower_Left_Edge, _upper_Right_Edge);
		rectangleCenter.rotate(center,angleDegrees);
		_lower_Left_Edge.rotate(center,angleDegrees);
		_upper_Right_Edge.rotate(center,angleDegrees);


public void rotate(Point_2D newCenter, double angleDegrees) {
    // Calculate the old center (midpoint between upperLeft and lowerRight)
    Point_2D oldCenter = calculateRectangleCenter(upperLeft, lowerRight);

    // Calculate the translation vector (difference between old and new centers)
    double translateX = newCenter.x() - oldCenter.x();
    double translateY = newCenter.y() - oldCenter.y();

    // Update the rectangle corners by applying the translation
    upperLeft.translate(translateX, translateY);
    lowerRight.translate(translateX, translateY);

    // Now rotate the rectangle around the new center using your existing Point_2D rotate method
    upperLeft.rotate(newCenter, angleDegrees);
    lowerRight.rotate(newCenter, angleDegrees);
}
